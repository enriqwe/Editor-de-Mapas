<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Asientos de Estadio</title>
    <!-- Tailwind CSS para estilos rápidos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Iconos Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Estilos personalizados */
        body { overflow: hidden; }
        
        #map-container {
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: grab;
            transform-origin: 0 0;
            position: relative;
        }

        #map-svg {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
        }

        /* Estilos SVG para las áreas */
        .area-polygon {
            fill: rgba(59, 130, 246, 0.2);
            stroke: rgba(59, 130, 246, 0.8);
            stroke-width: 2;
            cursor: move;
            transition: fill 0.2s;
        }
        .area-polygon:hover { fill: rgba(59, 130, 246, 0.4); }
        .area-polygon.selected {
            stroke: #ef4444; fill: rgba(239, 68, 68, 0.2); stroke-dasharray: 5,5;
        }
        .area-polygon.multi-selected {
            stroke: #ef4444; fill: rgba(239, 68, 68, 0.1); stroke-dasharray: 2,2;
        }

        /* Estilos Fondo */
        .bg-image-wrapper { cursor: default; }
        .bg-image-wrapper.editable { cursor: move; }
        .bg-image-frame { fill: none; stroke: transparent; stroke-width: 2; }
        .bg-image-wrapper.selected .bg-image-frame { stroke: #8b5cf6; stroke-dasharray: 5,5; }
        .bg-handle { fill: white; stroke: #8b5cf6; stroke-width: 2; cursor: nwse-resize; display: none; }
        .bg-image-wrapper.selected .bg-handle { display: block; }
        .bg-handle-0 { cursor: nw-resize; } .bg-handle-1 { cursor: ne-resize; }
        .bg-handle-2 { cursor: se-resize; } .bg-handle-3 { cursor: sw-resize; }

        /* Utiles Mapa */
        .front-edge { stroke: #ef4444; stroke-width: 4; pointer-events: none; }
        .front-arrow { fill: #ef4444; pointer-events: none; }
        .corner-handle { fill: white; stroke: #3b82f6; stroke-width: 2; cursor: crosshair; display: none; }
        .single-selected-group .corner-handle { display: block; }
        .single-selected-group .corner-handle:hover { fill: #3b82f6; }
        .rotate-handle-line { stroke: #3b82f6; stroke-width: 1; stroke-dasharray: 4; display: none; }
        .rotate-handle-circle { fill: white; stroke: #3b82f6; stroke-width: 2; cursor: grab; display: none; }
        .single-selected-group .rotate-handle-line, .single-selected-group .rotate-handle-circle { display: block; }

        /* Grid Editor */
        .seat-grid { display: grid; gap: 2px; padding: 20px; background: #f3f4f6; overflow: auto; max-height: 70vh; margin: auto; align-content: start; }
        .seat-cell { width: 24px; height: 24px; border-radius: 4px; background-color: #e5e7eb; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 8px; color: #6b7280; user-select: none; }
        .seat-cell.active { background-color: #10b981; color: white; border: 1px solid #059669; }
        .seat-cell:hover { opacity: 0.8; }
        .grid-header-col { display: flex; align-items: end; justify-content: center; font-size: 10px; font-weight: bold; color: #6b7280; padding-bottom: 2px; user-select: none; }
        .grid-header-row { display: flex; align-items: center; justify-content: end; font-size: 10px; font-weight: bold; color: #6b7280; padding-right: 4px; user-select: none; }
        
        /* Tree View Styles */
        .sector-header { background-color: #f3f4f6; font-weight: bold; padding: 6px 8px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; border-radius: 4px; margin-top: 4px; user-select: none; }
        .sector-header:hover { background-color: #e5e7eb; }
        .sector-header.active { background-color: #e0e7ff; color: #4338ca; border: 1px solid #c7d2fe; }
        .area-item { padding: 4px 8px 4px 24px; font-size: 12px; cursor: pointer; border-left: 2px solid transparent; display: flex; justify-content: space-between; }
        .area-item:hover { background-color: #f9fafb; }
        .area-item.active { background-color: #eff6ff; border-left-color: #3b82f6; font-weight: 500; }
        
        button:disabled { opacity: 0.5; cursor: not-allowed; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 h-screen flex flex-col font-sans">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 h-14 flex items-center justify-between px-4 shadow-sm z-30">
        <div class="flex items-center gap-2">
            <i data-lucide="armchair" class="text-blue-600"></i>
            <h1 class="font-bold text-lg hidden md:block">Stadium Map Editor</h1>
        </div>
        
        <div class="flex gap-1 items-center bg-gray-50 p-1 rounded border border-gray-200" id="alignment-tools">
            <div class="text-[10px] text-gray-400 font-bold uppercase mr-1 px-1">Alinear:</div>
            <button onclick="alignSelection('top')" class="p-1.5 hover:bg-gray-200 rounded text-gray-700" title="Alinear Arriba"><i data-lucide="align-vertical-justify-start" class="w-4 h-4"></i></button>
            <button onclick="alignSelection('bottom')" class="p-1.5 hover:bg-gray-200 rounded text-gray-700" title="Alinear Abajo"><i data-lucide="align-vertical-justify-end" class="w-4 h-4"></i></button>
            <div class="w-px h-4 bg-gray-300 mx-1"></div>
            <button onclick="alignSelection('left')" class="p-1.5 hover:bg-gray-200 rounded text-gray-700" title="Alinear Izquierda"><i data-lucide="align-horizontal-justify-start" class="w-4 h-4"></i></button>
            <button onclick="alignSelection('right')" class="p-1.5 hover:bg-gray-200 rounded text-gray-700" title="Alinear Derecha"><i data-lucide="align-horizontal-justify-end" class="w-4 h-4"></i></button>
        </div>

        <div class="flex gap-3 items-center">
            <div class="flex items-center gap-1 bg-gray-100 rounded px-1 border border-gray-200">
                <button onclick="document.getElementById('bgInput').click()" class="flex items-center gap-1 px-2 py-1.5 text-sm font-medium text-gray-700 hover:text-gray-900 rounded">
                    <i data-lucide="image"></i> <span class="hidden lg:inline">Imagen</span>
                </button>
                <div class="w-px h-4 bg-gray-300"></div>
                <button id="bg-lock-btn" onclick="toggleBgLock()" class="p-1.5 text-gray-500 hover:text-gray-800" title="Bloquear/Desbloquear fondo">
                    <i id="bg-lock-icon" data-lucide="lock" class="w-4 h-4"></i>
                </button>
            </div>
            <input type="file" id="bgInput" accept="image/*" class="hidden">

            <button onclick="document.getElementById('csvInput').click()" class="flex items-center gap-1 px-3 py-1.5 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded">
                <i data-lucide="upload"></i> Importar
            </button>
            <input type="file" id="csvInput" accept=".csv,.xlsx,.xls" class="hidden">

            <button onclick="exportData()" class="flex items-center gap-1 px-3 py-1.5 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded">
                <i data-lucide="download"></i> Exportar
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Sidebar -->
        <aside class="w-80 bg-white border-r border-gray-200 flex flex-col z-20 shadow-lg">
            <div class="p-4 border-b border-gray-100 bg-gray-50 h-1/2 overflow-y-auto">
                <h2 class="font-semibold text-gray-700 mb-2 flex items-center gap-2">
                    <i data-lucide="settings-2" class="w-4 h-4"></i> Propiedades
                </h2>
                
                <!-- 1. Estado Selección Múltiple -->
                <div id="multi-selection-info" class="hidden text-sm p-4 bg-blue-50 text-blue-800 rounded border border-blue-200 text-center">
                    <span class="font-bold block text-lg mb-1" id="multi-count">0</span>
                    Áreas seleccionadas
                </div>

                <!-- 2. Estado Edición Fondo -->
                <div id="bg-edit-info" class="hidden text-sm p-4 bg-purple-50 text-purple-800 rounded border border-purple-200">
                    <div class="font-bold flex items-center gap-2 mb-1"><i data-lucide="image" class="w-4 h-4"></i> Fondo</div>
                    <button onclick="toggleBgLock()" class="w-full bg-white border border-purple-200 text-purple-700 py-1 px-2 rounded hover:bg-purple-100 text-xs mt-2">Terminar Edición</button>
                </div>

                <!-- 3. Estado Sin Selección -->
                <div id="no-selection" class="text-sm text-gray-500 italic p-4 text-center border-2 border-dashed rounded bg-gray-50">
                    Selecciona un <b>Sector</b> o un <b>Área</b> del árbol inferior para ver sus propiedades.
                </div>

                <!-- 4. Formulario SECTOR -->
                <form id="sector-form" class="hidden space-y-3 text-sm border-l-4 border-indigo-500 pl-3">
                    <div class="text-xs font-bold text-indigo-600 uppercase mb-2">Editando Sector</div>
                    <div>
                        <label class="block text-xs font-medium text-gray-500">Sector ID</label>
                        <input type="text" id="prop-sec-id" class="w-full mt-1 border-gray-300 rounded-md shadow-sm border p-1 bg-gray-50 font-mono" oninput="updateSelectedSectorFromForm()">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-500">Nombre Sector</label>
                        <input type="text" id="prop-sec-title" class="w-full mt-1 border-gray-300 rounded-md shadow-sm border p-1" oninput="updateSelectedSectorFromForm()">
                    </div>
                    <div class="pt-2">
                        <button type="button" onclick="deleteSelectedSector()" class="text-red-600 hover:text-red-800 text-xs flex items-center gap-1">
                            <i data-lucide="trash-2" class="w-3 h-3"></i> Eliminar Sector (y sus áreas)
                        </button>
                    </div>
                </form>
                
                <!-- 5. Formulario ÁREA -->
                <form id="area-form" class="hidden space-y-3 text-sm border-l-4 border-blue-500 pl-3">
                    <div class="text-xs font-bold text-blue-600 uppercase mb-2">Editando Área</div>
                    
                    <!-- Area ID (Nuevo) -->
                    <div>
                        <label class="block text-xs font-medium text-gray-500">Area ID</label>
                        <input type="text" id="prop-area-id" class="w-full mt-1 border-gray-300 rounded-md shadow-sm border p-1 font-mono text-xs" oninput="updateSelectedAreaFromForm()">
                    </div>

                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="block text-xs font-medium text-gray-500">Título</label>
                            <input type="text" id="prop-title" class="w-full mt-1 border-gray-300 rounded-md shadow-sm border p-1" oninput="updateSelectedAreaFromForm()">
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-gray-500">Código Visual</label>
                            <input type="text" id="prop-code" class="w-full mt-1 border-gray-300 rounded-md shadow-sm border p-1" oninput="updateSelectedAreaFromForm()">
                        </div>
                    </div>

                    <!-- Selector de Sector (Nuevo) -->
                    <div>
                        <label class="block text-xs font-medium text-gray-500">Pertenece al Sector</label>
                        <select id="prop-sector-select" class="w-full mt-1 border-gray-300 rounded-md shadow-sm border p-1" onchange="updateSelectedAreaSector()">
                            <!-- Opciones generadas dinámicamente -->
                        </select>
                    </div>
                    
                    <button type="button" onclick="openSeatEditor()" class="w-full mt-2 bg-blue-600 text-white py-2 rounded font-medium hover:bg-blue-700 shadow-sm flex justify-center items-center gap-2">
                        <i data-lucide="grid-3x3" class="w-4 h-4"></i> Editar Asientos
                    </button>
                    
                    <div class="pt-2 border-t mt-2 flex justify-between items-center">
                         <button type="button" onclick="deleteSelectedArea()" class="text-red-600 hover:text-red-800 text-xs flex items-center gap-1">
                            <i data-lucide="trash-2" class="w-3 h-3"></i> Eliminar
                        </button>
                    </div>
                </form>
            </div>

            <!-- Lista en Árbol -->
            <div class="flex-1 overflow-y-auto p-2 bg-gray-50 border-t border-gray-200">
                <div class="flex justify-between items-center mb-2 px-2 sticky top-0 bg-gray-50 py-1 z-10">
                    <h3 class="font-bold text-xs text-gray-500 uppercase">Estructura del Estadio</h3>
                    <div class="flex gap-1">
                        <button onclick="createNewSector()" class="text-indigo-600 hover:text-indigo-800 text-xs font-bold border border-indigo-200 bg-white px-2 py-1 rounded shadow-sm hover:shadow" title="Crear Sector">
                            + Sector
                        </button>
                        <button onclick="createNewArea()" class="text-blue-600 hover:text-blue-800 text-xs font-bold border border-blue-200 bg-white px-2 py-1 rounded shadow-sm hover:shadow" title="Crear Área">
                            + Área
                        </button>
                    </div>
                </div>
                <!-- Contenedor del Árbol -->
                <div id="tree-list" class="space-y-1 pb-4">
                    <!-- Generado dinámicamente -->
                </div>
            </div>
        </aside>

        <!-- Canvas Container Wrapper -->
        <!-- La 'relative' aquí es clave para que los controles absolute se posicionen respecto a este wrapper, no al viewport scrolleable -->
        <div class="flex-1 relative overflow-hidden flex flex-col">
            
            <!-- Zoom Controls (Ahora están fuera del main-viewport, fijos en la esquina) -->
            <div class="absolute top-4 right-4 z-50 flex flex-col gap-1 bg-white shadow rounded">
                <button onclick="adjustZoom(0.1)" class="p-2 hover:bg-gray-100">+</button>
                <button onclick="resetZoom()" class="p-2 text-xs font-bold hover:bg-gray-100">100%</button>
                <button onclick="adjustZoom(-0.1)" class="p-2 hover:bg-gray-100">-</button>
            </div>

            <!-- Canvas Scrollable -->
            <main id="main-viewport" class="flex-1 relative bg-gray-200 overflow-hidden w-full h-full">
                <div id="map-container" class="relative origin-top-left w-[4000px] h-[4000px]">
                    <svg id="map-svg" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#ef4444" />
                            </marker>
                        </defs>
                        <g id="bg-layer"></g>
                        <g id="areas-layer"></g>
                    </svg>
                </div>
            </main>
        </div>
    </div>

    <!-- Modal Asientos -->
    <div id="seat-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-lg shadow-2xl w-11/12 max-w-6xl h-[95vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center bg-gray-50 rounded-t-lg">
                <div class="flex items-center gap-4">
                    <div>
                        <h2 class="text-xl font-bold text-gray-800" id="modal-title">Editor de Asientos</h2>
                        <p class="text-xs text-gray-500">Configura grid y asientos</p>
                    </div>
                    <!-- Inputs Dimensiones -->
                    <div class="flex items-center gap-3 bg-white px-3 py-1.5 rounded-lg border border-gray-200 shadow-sm ml-4">
                        <div class="flex items-center gap-2">
                            <span class="text-xs font-bold text-gray-500">FILAS:</span>
                            <input type="number" id="modal-row-min" class="w-14 text-center border rounded p-1 text-sm" onchange="updateGridDimensions()">
                            <span class="text-gray-400">-</span>
                            <input type="number" id="modal-row-max" class="w-14 text-center border rounded p-1 text-sm" onchange="updateGridDimensions()">
                        </div>
                        <div class="w-px h-6 bg-gray-300"></div>
                        <div class="flex items-center gap-2">
                            <span class="text-xs font-bold text-gray-500">COLS:</span>
                            <input type="number" id="modal-seat-min" class="w-14 text-center border rounded p-1 text-sm" onchange="updateGridDimensions()">
                            <span class="text-gray-400">-</span>
                            <input type="number" id="modal-seat-max" class="w-14 text-center border rounded p-1 text-sm" onchange="updateGridDimensions()">
                        </div>
                    </div>
                </div>
                <button onclick="closeSeatEditor()" class="text-gray-500 hover:text-gray-800"><i data-lucide="x"></i></button>
            </div>
            
            <div class="flex-1 overflow-hidden flex flex-col bg-gray-100 p-4">
                <div class="flex justify-between mb-2 text-sm text-gray-600 px-2 items-center">
                    <span id="seat-count-display">0 Asientos</span>
                    <div class="flex items-center gap-1 bg-white px-2 py-1 rounded shadow-sm border border-gray-200">
                        <button onclick="expandGrid('top')" class="p-1 hover:bg-blue-50 text-blue-600 rounded"><i data-lucide="arrow-up-from-line" class="w-4 h-4"></i></button>
                        <button onclick="expandGrid('bottom')" class="p-1 hover:bg-blue-50 text-blue-600 rounded"><i data-lucide="arrow-down-to-line" class="w-4 h-4"></i></button>
                        <div class="w-px h-4 bg-gray-300 mx-1"></div>
                        <button onclick="expandGrid('left')" class="p-1 hover:bg-blue-50 text-blue-600 rounded"><i data-lucide="arrow-left-from-line" class="w-4 h-4"></i></button>
                        <button onclick="expandGrid('right')" class="p-1 hover:bg-blue-50 text-blue-600 rounded"><i data-lucide="arrow-right-to-line" class="w-4 h-4"></i></button>
                    </div>
                </div>
                <div class="flex-1 border rounded bg-white shadow-inner relative overflow-auto flex justify-center p-8">
                     <div id="grid-container" class="seat-grid select-none"></div>
                </div>
            </div>
            <div class="p-4 border-t flex justify-end gap-2 bg-gray-50 rounded-b-lg">
                <button onclick="fillAllSeats()" class="px-4 py-2 text-sm bg-white border border-gray-300 rounded text-gray-700">Llenar</button>
                <button onclick="clearAllSeats()" class="px-4 py-2 text-sm bg-white border border-red-300 rounded text-red-600">Vaciar</button>
                <button onclick="closeSeatEditor()" class="px-4 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 font-medium">Hecho</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. Estado ---
        const AppState = {
            seats: [], 
            // NUEVO: Array de Sectores
            sectors: [
                { id: 'default-sec', title: 'Sector General' } // Sector por defecto
            ],
            areas: [], // { id, title, code, sectorId, points: [], ... }
            
            background: { url: null, x: 0, y: 0, w: 0, h: 0, locked: true, selected: false },
            zoom: 1,
            
            // Selección
            selectedAreaIds: [], // Para selección múltiple de áreas en el mapa
            selectedSectorId: null, // Para saber si estamos editando un sector en la sidebar

            isDraggingMap: false,
            mapOffset: { x: 0, y: 0 },
            dragStart: { x: 0, y: 0 },
            
            interactionMode: null,
            activeAreaId: null, 
            activeCornerIndex: -1,
            initialClickPoint: { x: 0, y: 0 },
            initialPointsMap: {}, 
            initialCenter: { x: 0, y: 0 }, 
            initialAngle: 0,
            initialBgRect: { x:0, y:0, w:0, h:0 }
        };

        lucide.createIcons();

        // --- 2. Utils ---
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        function getCentroid(points) {
            let x = 0, y = 0; points.forEach(p => { x += p.x; y += p.y; });
            return { x: x / points.length, y: y / points.length };
        }
        function getBounds(points) {
            const xs = points.map(p => p.x), ys = points.map(p => p.y);
            return { minX: Math.min(...xs), maxX: Math.max(...xs), minY: Math.min(...ys), maxY: Math.max(...ys), width: Math.max(...xs) - Math.min(...xs), height: Math.max(...ys) - Math.min(...ys) };
        }

        // --- 3. CSV Import ---
        function parseCSV(text) {
            const lines = text.split(/\r\n|\n/);
            const headers = lines[0].split(',').map(h => h.trim().toUpperCase());
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                // Manejo básico de comas, idealmente usar librería robusta si hay comillas
                const values = lines[i].split(','); 
                const entry = {};
                headers.forEach((h, index) => { entry[h] = values[index] ? values[index].trim() : ''; });
                data.push(entry);
            }
            return data;
        }

        document.getElementById('csvInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => processImportedData(parseCSV(evt.target.result));
            reader.readAsText(file);
        });

        function processImportedData(data) {
            // 1. Extraer Sectores Únicos
            const uniqueSectors = {};
            data.forEach(row => {
                const sId = row['SECTOR ID'];
                const sTitle = row['SECTOR TITLE'];
                if (sId && !uniqueSectors[sId]) {
                    uniqueSectors[sId] = sTitle || 'Sin Nombre';
                }
            });

            // Actualizar AppState.sectors (manteniendo el default si se quiere, o limpiando)
            // Aquí vamos a mezclar: si el ID existe, actualizamos título, si no, añadimos.
            Object.keys(uniqueSectors).forEach(sId => {
                const existing = AppState.sectors.find(s => s.id === sId);
                if (existing) existing.title = uniqueSectors[sId];
                else AppState.sectors.push({ id: sId, title: uniqueSectors[sId] });
            });

            // 2. Procesar Asientos
            AppState.seats = data.map(row => ({
                seatId: row['SEAT ID'] || generateUUID(),
                areaId: row['AREA ID'],
                areaTitle: row['AREA TITLE'],
                areaCode: row['AREA CODE'],
                sectorId: row['SECTOR ID'] || 'default-sec', // Fallback
                sectorTitle: row['SECTOR TITLE'],
                rowPos: parseInt(row['ROW POSITION']) || 1,
                seatPos: parseInt(row['SEAT POSITION']) || 1,
                rowNum: row['ROW NUMBER'] || '',
                seatNum: row['SEAT NUMBER'] || ''
            }));

            // 3. Descubrir/Actualizar Áreas
            const uniqueAreaIds = [...new Set(AppState.seats.map(s => s.areaId))];
            let areasAddedCount = 0;

            uniqueAreaIds.forEach(id => {
                let area = AppState.areas.find(a => a.id === id);
                const sampleSeat = AppState.seats.find(s => s.areaId === id);
                const areaSeats = AppState.seats.filter(s => s.areaId === id);
                
                const rPos = areaSeats.map(s => s.rowPos);
                const sPos = areaSeats.map(s => s.seatPos);
                const cMinR = Math.min(...rPos), cMaxR = Math.max(...rPos);
                const cMinS = Math.min(...sPos), cMaxS = Math.max(...sPos);

                if (!area) {
                    // Layout Grid simple
                    const col = areasAddedCount % 10;
                    const row = Math.floor(areasAddedCount / 10);
                    const startX = 50 + (col * 160);
                    const startY = 50 + (row * 120);
                    const w = 140, h = 90;

                    area = {
                        id: id,
                        title: sampleSeat.areaTitle || 'Nueva Área',
                        code: sampleSeat.areaCode || 'NA',
                        sectorId: sampleSeat.sectorId || 'default-sec', // Link vital
                        points: [{x: startX, y: startY}, {x: startX + w, y: startY}, {x: startX + w, y: startY + h}, {x: startX, y: startY + h}],
                        rowMin: cMinR, rowMax: cMaxR,
                        seatMin: cMinS, seatMax: cMaxS
                    };
                    AppState.areas.push(area);
                    areasAddedCount++;
                } else {
                    // Update existente
                    area.rowMin = Math.min(area.rowMin, cMinR);
                    area.rowMax = Math.max(area.rowMax, cMaxR);
                    area.seatMin = Math.min(area.seatMin, cMinS);
                    area.seatMax = Math.max(area.seatMax, cMaxS);
                    // Asegurar que el sectorId esté sincronizado si vino del Excel
                    if (sampleSeat.sectorId) area.sectorId = sampleSeat.sectorId;
                }
            });

            renderMap();
            renderTreeList();
            updateUI();
        }

        function exportData() {
            const headers = ['SECTOR ID','SECTOR TITLE','AREA ID','AREA TITLE','AREA CODE','SEAT ID','ROW POSITION','SEAT POSITION','ROW NUMBER','SEAT NUMBER'];
            let csvContent = headers.join(',') + "\n";
            AppState.seats.forEach(seat => {
                const parentArea = AppState.areas.find(a => a.id === seat.areaId);
                const parentSector = parentArea ? AppState.sectors.find(s => s.id === parentArea.sectorId) : null;
                
                const row = [
                    parentSector ? parentSector.id : (seat.sectorId || ''),
                    parentSector ? parentSector.title : (seat.sectorTitle || ''),
                    seat.areaId,
                    parentArea ? parentArea.title : seat.areaTitle,
                    parentArea ? parentArea.code : seat.areaCode,
                    seat.seatId,
                    seat.rowPos,
                    seat.seatPos,
                    seat.rowNum,
                    seat.seatNum
                ];
                csvContent += row.join(',') + "\n";
            });
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", "estadio_export.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- 4. Render Map ---
        const mapContainer = document.getElementById('map-container');
        const bgLayer = document.getElementById('bg-layer');
        const areasLayer = document.getElementById('areas-layer');

        document.getElementById('bgInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                const tempImg = new Image();
                tempImg.src = url;
                tempImg.onload = () => {
                    AppState.background.url = url;
                    AppState.background.w = tempImg.naturalWidth;
                    AppState.background.h = tempImg.naturalHeight;
                    AppState.background.locked = false;
                    AppState.background.selected = true;
                    updateBgUI(); renderMap();
                };
            }
        });

        function toggleBgLock() {
            AppState.background.locked = !AppState.background.locked;
            if (AppState.background.locked) AppState.background.selected = false;
            else { AppState.background.selected = true; AppState.selectedAreaIds = []; AppState.selectedSectorId = null; }
            updateBgUI(); renderMap(); updateUI();
        }

        function updateBgUI() {
            const icon = document.getElementById('bg-lock-icon');
            const btn = document.getElementById('bg-lock-btn');
            if (AppState.background.locked) { icon.setAttribute('data-lucide', 'lock'); btn.className = "p-1.5 text-gray-500 hover:text-gray-800"; }
            else { icon.setAttribute('data-lucide', 'lock-open'); btn.className = "p-1.5 text-purple-600 bg-purple-100 rounded"; }
            lucide.createIcons();
        }

        function renderMap() {
            // Fondo
            bgLayer.innerHTML = '';
            if (AppState.background.url) {
                const gBg = document.createElementNS("http://www.w3.org/2000/svg", "g");
                gBg.setAttribute("class", `bg-image-wrapper ${!AppState.background.locked?'editable':''} ${AppState.background.selected?'selected':''}`);
                const img = document.createElementNS("http://www.w3.org/2000/svg", "image");
                img.setAttribute("href", AppState.background.url);
                img.setAttribute("x", AppState.background.x); img.setAttribute("y", AppState.background.y);
                img.setAttribute("width", AppState.background.w); img.setAttribute("height", AppState.background.h);
                img.addEventListener('mousedown', (e) => { if (!AppState.background.locked) startMoveBackground(e); });
                gBg.appendChild(img);

                if (AppState.background.selected && !AppState.background.locked) {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("class", "bg-image-frame"); rect.setAttribute("pointer-events", "none");
                    rect.setAttribute("x", AppState.background.x); rect.setAttribute("y", AppState.background.y);
                    rect.setAttribute("width", AppState.background.w); rect.setAttribute("height", AppState.background.h);
                    gBg.appendChild(rect);
                    const coords = [
                        {x: AppState.background.x, y: AppState.background.y},
                        {x: AppState.background.x + AppState.background.w, y: AppState.background.y},
                        {x: AppState.background.x + AppState.background.w, y: AppState.background.y + AppState.background.h},
                        {x: AppState.background.x, y: AppState.background.y + AppState.background.h}
                    ];
                    coords.forEach((c, i) => {
                        const h = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        h.setAttribute("class", `bg-handle bg-handle-${i}`); h.setAttribute("x", c.x-6); h.setAttribute("y", c.y-6); h.setAttribute("width", 12); h.setAttribute("height", 12);
                        h.addEventListener('mousedown', (e) => startResizeBackground(e, i));
                        gBg.appendChild(h);
                    });
                }
                bgLayer.appendChild(gBg);
            }

            // Áreas
            areasLayer.innerHTML = '';
            AppState.areas.forEach(area => {
                const isSelected = AppState.selectedAreaIds.includes(area.id);
                const isSingle = isSelected && AppState.selectedAreaIds.length === 1;

                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("class", isSingle ? "single-selected-group" : "");
                
                const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                poly.setAttribute("points", area.points.map(p => `${p.x},${p.y}`).join(" "));
                let cls = "area-polygon";
                if (isSelected) cls += AppState.selectedAreaIds.length > 1 ? " multi-selected" : " selected";
                poly.setAttribute("class", cls);
                poly.addEventListener('mousedown', (e) => startMoveArea(e, area));
                poly.addEventListener('dblclick', (e) => { e.stopPropagation(); openSeatEditor(); });
                g.appendChild(poly);

                const c = getCentroid(area.points);
                const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                txt.setAttribute("x", c.x); txt.setAttribute("y", c.y); txt.setAttribute("text-anchor", "middle"); txt.setAttribute("dominant-baseline", "middle");
                txt.setAttribute("fill", "black"); txt.setAttribute("font-size", "12"); txt.setAttribute("font-weight", "bold"); txt.setAttribute("pointer-events", "none");
                txt.textContent = area.code;
                g.appendChild(txt);

                // Frente
                const p3 = area.points[2], p4 = area.points[3];
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("class", "front-edge"); line.setAttribute("x1", p4.x); line.setAttribute("y1", p4.y); line.setAttribute("x2", p3.x); line.setAttribute("y2", p3.y);
                g.appendChild(line);

                const mx = (p3.x+p4.x)/2, my = (p3.y+p4.y)/2, dx = p3.x-p4.x, dy = p3.y-p4.y, l = Math.sqrt(dx*dx+dy*dy);
                const nx = -dy/l, ny = dx/l;
                const arrow = document.createElementNS("http://www.w3.org/2000/svg", "line");
                arrow.setAttribute("x1", mx); arrow.setAttribute("y1", my); arrow.setAttribute("x2", mx+nx*15); arrow.setAttribute("y2", my+ny*15);
                arrow.setAttribute("stroke", "#ef4444"); arrow.setAttribute("stroke-width", "2"); arrow.setAttribute("marker-end", "url(#arrowhead)"); arrow.setAttribute("pointer-events", "none");
                g.appendChild(arrow);

                // Handles
                if (isSingle) {
                    area.points.forEach((p, i) => {
                        const h = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        h.setAttribute("class", "corner-handle"); h.setAttribute("cx", p.x); h.setAttribute("cy", p.y); h.setAttribute("r", 5);
                        h.addEventListener('mousedown', (e) => startMoveCorner(e, area, i));
                        g.appendChild(h);
                    });
                    // Rot
                    const p1=area.points[0], p2=area.points[1];
                    const tmx=(p1.x+p2.x)/2, tmy=(p1.y+p2.y)/2;
                    const vdx=tmx-c.x, vdy=tmy-c.y, vl=Math.sqrt(vdx*vdx+vdy*vdy);
                    const rx=tmx+(vdx/vl)*30, ry=tmy+(vdy/vl)*30;
                    const rl = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    rl.setAttribute("class", "rotate-handle-line"); rl.setAttribute("x1", tmx); rl.setAttribute("y1", tmy); rl.setAttribute("x2", rx); rl.setAttribute("y2", ry);
                    g.appendChild(rl);
                    const rc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    rc.setAttribute("class", "rotate-handle-circle"); rc.setAttribute("cx", rx); rc.setAttribute("cy", ry); rc.setAttribute("r", 6);
                    rc.addEventListener('mousedown', (e) => startRotateArea(e, area));
                    g.appendChild(rc);
                }
                areasLayer.appendChild(g);
            });
        }

        // --- 5. Interacciones Mouse ---
        function getMousePos(evt) {
            const r = mapContainer.getBoundingClientRect();
            return { x: (evt.clientX - r.left) / AppState.zoom, y: (evt.clientY - r.top) / AppState.zoom };
        }

        function toggleSelection(id, add) {
            AppState.background.selected = false;
            AppState.selectedSectorId = null; // Al seleccionar áreas en mapa, deseleccionamos sector de sidebar
            if (add) {
                if (AppState.selectedAreaIds.includes(id)) AppState.selectedAreaIds = AppState.selectedAreaIds.filter(i => i !== id);
                else AppState.selectedAreaIds.push(id);
            } else {
                AppState.selectedAreaIds = [id];
            }
            updateUI();
        }

        function startMoveArea(e, area) {
            e.stopPropagation();
            if (e.shiftKey) { if (!AppState.selectedAreaIds.includes(area.id)) AppState.selectedAreaIds.push(area.id); }
            else { if (!AppState.selectedAreaIds.includes(area.id)) AppState.selectedAreaIds = [area.id]; }
            
            AppState.background.selected = false;
            AppState.selectedSectorId = null;

            updateUI();
            AppState.interactionMode = 'move_area';
            AppState.activeAreaId = area.id;
            AppState.initialClickPoint = getMousePos(e);
            AppState.initialPointsMap = {};
            AppState.selectedAreaIds.forEach(id => {
                const a = AppState.areas.find(ar => ar.id === id);
                AppState.initialPointsMap[id] = JSON.parse(JSON.stringify(a.points));
            });
            renderMap();
        }

        function startMoveCorner(e, area, idx) {
            e.stopPropagation();
            AppState.interactionMode = 'move_corner';
            AppState.activeAreaId = area.id; AppState.activeCornerIndex = idx;
            AppState.initialClickPoint = getMousePos(e);
            AppState.initialPointsMap = {[area.id]: JSON.parse(JSON.stringify(area.points))};
        }

        function startRotateArea(e, area) {
            e.stopPropagation();
            AppState.interactionMode = 'rotate_area'; AppState.activeAreaId = area.id;
            AppState.initialCenter = getCentroid(area.points);
            AppState.initialPointsMap = {[area.id]: JSON.parse(JSON.stringify(area.points))};
            const m = getMousePos(e);
            AppState.initialAngle = Math.atan2(m.y - AppState.initialCenter.y, m.x - AppState.initialCenter.x);
        }

        function startMoveBackground(e) {
            e.stopPropagation();
            AppState.background.selected = true; AppState.selectedAreaIds = []; AppState.selectedSectorId = null;
            updateUI(); renderMap();
            AppState.interactionMode = 'move_bg';
            AppState.initialClickPoint = getMousePos(e);
            AppState.initialBgRect = {x: AppState.background.x, y: AppState.background.y};
        }

        function startResizeBackground(e, idx) {
            e.stopPropagation();
            AppState.interactionMode = 'resize_bg'; AppState.activeCornerIndex = idx;
            AppState.initialClickPoint = getMousePos(e);
            AppState.initialBgRect = {...AppState.background};
        }

        document.addEventListener('mousemove', (e) => {
            if (!AppState.interactionMode) return;
            const m = getMousePos(e);
            const dx = m.x - AppState.initialClickPoint.x, dy = m.y - AppState.initialClickPoint.y;

            if (AppState.interactionMode === 'move_area') {
                AppState.selectedAreaIds.forEach(id => {
                    const a = AppState.areas.find(ar => ar.id === id);
                    const init = AppState.initialPointsMap[id];
                    if (a && init) a.points = init.map(p => ({x: p.x+dx, y: p.y+dy}));
                });
                renderMap();
            } else if (AppState.interactionMode === 'move_corner') {
                const a = AppState.areas.find(ar => ar.id === AppState.activeAreaId);
                const init = AppState.initialPointsMap[a.id];
                a.points[AppState.activeCornerIndex] = {x: init[AppState.activeCornerIndex].x+dx, y: init[AppState.activeCornerIndex].y+dy};
                renderMap();
            } else if (AppState.interactionMode === 'rotate_area') {
                const a = AppState.areas.find(ar => ar.id === AppState.activeAreaId);
                const ca = Math.atan2(m.y - AppState.initialCenter.y, m.x - AppState.initialCenter.x);
                const da = ca - AppState.initialAngle;
                const cos = Math.cos(da), sin = Math.sin(da), cx = AppState.initialCenter.x, cy = AppState.initialCenter.y;
                const init = AppState.initialPointsMap[a.id];
                a.points = init.map(p => ({x: cx+(p.x-cx)*cos-(p.y-cy)*sin, y: cy+(p.x-cx)*sin+(p.y-cy)*cos}));
                renderMap();
            } else if (AppState.interactionMode === 'move_bg') {
                AppState.background.x = AppState.initialBgRect.x + dx;
                AppState.background.y = AppState.initialBgRect.y + dy;
                renderMap();
            } else if (AppState.interactionMode === 'resize_bg') {
                const r = AppState.initialBgRect, idx = AppState.activeCornerIndex;
                if (idx===0) { AppState.background.x=r.x+dx; AppState.background.y=r.y+dy; AppState.background.w=r.w-dx; AppState.background.h=r.h-dy; }
                else if (idx===1) { AppState.background.y=r.y+dy; AppState.background.w=r.w+dx; AppState.background.h=r.h-dy; }
                else if (idx===2) { AppState.background.w=r.w+dx; AppState.background.h=r.h+dy; }
                else if (idx===3) { AppState.background.x=r.x+dx; AppState.background.w=r.w-dx; AppState.background.h=r.h+dy; }
                renderMap();
            }
        });

        document.addEventListener('mouseup', () => AppState.interactionMode = null);

        const viewport = document.getElementById('main-viewport');
        viewport.addEventListener('mousedown', (e) => {
            if (e.target.id === 'main-viewport' || e.target.id === 'map-svg' || (e.target.tagName==='image' && AppState.background.locked)) {
                AppState.isDraggingMap = true; AppState.dragStart = {x: e.clientX, y: e.clientY};
                if (e.target.tagName !== 'image') {
                    AppState.selectedAreaIds = []; AppState.background.selected = false; AppState.selectedSectorId = null;
                }
                updateUI(); renderMap();
            }
        });
        document.addEventListener('mousemove', (e) => {
            if (AppState.isDraggingMap) {
                viewport.scrollLeft -= (e.clientX - AppState.dragStart.x);
                viewport.scrollTop -= (e.clientY - AppState.dragStart.y);
                AppState.dragStart = {x: e.clientX, y: e.clientY};
            }
        });
        document.addEventListener('mouseup', () => AppState.isDraggingMap = false);

        function adjustZoom(d) { AppState.zoom = Math.max(0.1, Math.min(3, AppState.zoom + d)); mapContainer.style.transform = `scale(${AppState.zoom})`; }
        function resetZoom() { AppState.zoom = 1; mapContainer.style.transform = `scale(1)`; }

        // --- 6. UI Logic & Tree View ---
        
        // Función para renderizar el árbol lateral (Sector -> Áreas)
        function renderTreeList() {
            const list = document.getElementById('tree-list');
            list.innerHTML = '';
            
            AppState.sectors.forEach(sector => {
                // Contenedor del Sector
                const secContainer = document.createElement('div');
                
                // Header del Sector
                const secHeader = document.createElement('div');
                secHeader.className = `sector-header ${AppState.selectedSectorId === sector.id ? 'active' : ''}`;
                secHeader.innerHTML = `
                    <div class="flex items-center gap-1">
                        <i data-lucide="folder" class="w-3 h-3 text-indigo-500"></i>
                        <span>${sector.title}</span>
                    </div>
                    <span class="text-[10px] text-gray-400">(${sector.id})</span>
                `;
                secHeader.onclick = () => selectSector(sector.id);
                secContainer.appendChild(secHeader);
                
                // Lista de Áreas dentro del Sector
                const sectorAreas = AppState.areas.filter(a => a.sectorId === sector.id);
                
                sectorAreas.forEach(area => {
                    const isSel = AppState.selectedAreaIds.includes(area.id);
                    const item = document.createElement('div');
                    item.className = `area-item ${isSel ? 'active' : ''}`;
                    item.innerHTML = `<span>${area.title}</span><span class="text-gray-400">${area.code}</span>`;
                    item.onclick = (e) => {
                        e.stopPropagation();
                        if (e.ctrlKey || e.metaKey) toggleSelection(area.id, true);
                        else toggleSelection(area.id, false);
                        renderMap();
                    };
                    secContainer.appendChild(item);
                });
                
                list.appendChild(secContainer);
            });
            lucide.createIcons();
        }

        function selectSector(id) {
            AppState.selectedSectorId = id;
            AppState.selectedAreaIds = []; // Limpiar selección de áreas
            AppState.background.selected = false;
            updateUI();
        }

        function updateUI() {
            renderTreeList();
            
            const noSel = document.getElementById('no-selection');
            const multiInfo = document.getElementById('multi-selection-info');
            const bgEditInfo = document.getElementById('bg-edit-info');
            const areaForm = document.getElementById('area-form');
            const sectorForm = document.getElementById('sector-form');
            const tools = document.getElementById('alignment-tools');

            // Reset visibilidad
            [noSel, multiInfo, bgEditInfo, areaForm, sectorForm].forEach(el => el.classList.add('hidden'));
            
            // Alineación solo si hay >1 área
            const canAlign = AppState.selectedAreaIds.length > 1;
            tools.style.opacity = canAlign ? "1" : "0.5";
            tools.querySelectorAll('button').forEach(b => b.disabled = !canAlign);

            if (!AppState.background.locked && AppState.background.selected) {
                bgEditInfo.classList.remove('hidden');
            } else if (AppState.selectedSectorId) {
                // Editando Sector
                sectorForm.classList.remove('hidden');
                populateSectorForm();
            } else if (AppState.selectedAreaIds.length === 1) {
                // Editando 1 Área
                areaForm.classList.remove('hidden');
                populateAreaForm();
            } else if (AppState.selectedAreaIds.length > 1) {
                multiInfo.classList.remove('hidden');
                document.getElementById('multi-count').innerText = AppState.selectedAreaIds.length;
            } else {
                noSel.classList.remove('hidden');
            }
        }

        // --- Gestión Sectores ---
        function createNewSector() {
            // Nombre por defecto
            const nextIdx = AppState.sectors.length + 1;
            const defaultId = `SECTOR-${nextIdx}`;
            
            let newId = prompt("ID del nuevo Sector:", defaultId);
            
            // Si cancela, salimos
            if (newId === null) return; 
            
            // Limpieza y validación
            newId = newId.trim();
            if (newId === "") {
                alert("El ID no puede estar vacío.");
                return;
            }
            
            // Comprobar duplicados (case insensitive)
            if (AppState.sectors.some(s => s.id.toUpperCase() === newId.toUpperCase())) {
                alert("Ya existe un sector con ese ID.");
                return;
            }

            // Crear sector
            AppState.sectors.push({ id: newId, title: newId });
            
            // Seleccionar el nuevo sector para editarlo
            selectSector(newId);
            
            // Forzar scroll al final de la lista para ver el nuevo elemento
            setTimeout(() => {
                const list = document.getElementById('tree-list');
                // Scroll al fondo absoluto
                if (list) list.scrollTop = list.scrollHeight;
            }, 100);
        }

        function populateSectorForm() {
            const s = AppState.sectors.find(s => s.id === AppState.selectedSectorId);
            if (!s) return;
            document.getElementById('prop-sec-id').value = s.id;
            document.getElementById('prop-sec-title').value = s.title;
        }

        function updateSelectedSectorFromForm() {
            const s = AppState.sectors.find(s => s.id === AppState.selectedSectorId);
            if (!s) return;
            
            const newId = document.getElementById('prop-sec-id').value;
            const newTitle = document.getElementById('prop-sec-title').value;

            // Si cambiamos el ID, hay que actualizar todas las áreas vinculadas
            if (newId !== s.id) {
                // Verificar colisión simple
                if (AppState.sectors.find(x => x.id === newId && x !== s)) return; // ID ocupado
                
                // Migrar áreas
                AppState.areas.forEach(a => {
                    if (a.sectorId === s.id) a.sectorId = newId;
                });
                s.id = newId;
                AppState.selectedSectorId = newId;
            }
            s.title = newTitle;
            renderTreeList();
        }

        function deleteSelectedSector() {
            const sId = AppState.selectedSectorId;
            const count = AppState.areas.filter(a => a.sectorId === sId).length;
            if(!confirm(`¿Borrar el sector "${sId}" y sus ${count} áreas asociadas?`)) return;
            
            // 1. Identificar áreas a borrar
            const areasToDelete = AppState.areas.filter(a => a.sectorId === sId).map(a => a.id);
            
            // 2. Borrar asientos de esas áreas (IMPORTANTE: Evitar huérfanos)
            AppState.seats = AppState.seats.filter(s => !areasToDelete.includes(s.areaId));
            
            // 3. Borrar áreas
            AppState.areas = AppState.areas.filter(a => a.sectorId !== sId);
            
            // 4. Borrar sector
            AppState.sectors = AppState.sectors.filter(s => s.id !== sId);
            
            AppState.selectedSectorId = null;
            renderMap();
            updateUI();
        }

        // --- Gestión Áreas ---
        function populateAreaForm() {
            const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]);
            if (!a) return;
            document.getElementById('prop-area-id').value = a.id;
            document.getElementById('prop-title').value = a.title;
            document.getElementById('prop-code').value = a.code;
            
            // Poblar dropdown de sectores
            const sel = document.getElementById('prop-sector-select');
            sel.innerHTML = '';
            AppState.sectors.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s.id;
                opt.innerText = `${s.title} (${s.id})`;
                if (s.id === a.sectorId) opt.selected = true;
                sel.appendChild(opt);
            });
        }

        function updateSelectedAreaFromForm() {
            const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]);
            if (!a) return;
            a.id = document.getElementById('prop-area-id').value;
            a.title = document.getElementById('prop-title').value;
            a.code = document.getElementById('prop-code').value;
            renderTreeList(); renderMap();
        }

        function updateSelectedAreaSector() {
            const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]);
            if (!a) return;
            a.sectorId = document.getElementById('prop-sector-select').value;
            renderTreeList(); // Moverá el área en el árbol
        }

        function createNewArea() {
            // Decidir a qué sector va: el seleccionado, o el primero
            let targetSectorId = AppState.selectedSectorId || (AppState.sectors[0] ? AppState.sectors[0].id : 'default-sec');
            
            // Si no existen sectores, crear el default
            if (AppState.sectors.length === 0) {
                AppState.sectors.push({ id: 'default-sec', title: 'General' });
                targetSectorId = 'default-sec';
            }

            const newId = generateUUID();
            
            // Lógica de Posicionamiento Inteligente (Cercanía)
            let startX = 100 + viewport.scrollLeft;
            let startY = 100 + viewport.scrollTop;
            
            // 1. Intentar usar área seleccionada como referencia
            let refArea = null;
            if (AppState.selectedAreaIds.length > 0) {
                refArea = AppState.areas.find(a => a.id === AppState.selectedAreaIds[0]);
            } else if (AppState.areas.length > 0) {
                // 2. Si no, la última creada
                refArea = AppState.areas[AppState.areas.length - 1];
            }

            if (refArea) {
                const b = getBounds(refArea.points);
                // Colocar justo a la derecha con un margen pequeño (10px)
                startX = b.maxX + 10;
                startY = b.minY; // Alinear arriba
                
                // Si se sale mucho del canvas (wrap simple opcional, pero mejor que se pegue siempre)
                // Si se sale > 3800 (casi límite), volver al inicio de la fila siguiente
                if (startX > 3800) {
                    startX = 100;
                    startY = b.maxY + 10;
                }
            }

            const w=120, h=80;
            AppState.areas.push({
                id: newId, title: 'Nueva Área', code: 'NEW', 
                sectorId: targetSectorId,
                points: [{x:startX,y:startY},{x:startX+w,y:startY},{x:startX+w,y:startY+h},{x:startX,y:startY+h}],
                rowMin: 1, rowMax: 5, seatMin: 1, seatMax: 10
            });
            toggleSelection(newId, false); // Seleccionar la nueva para encadenar creaciones
            renderMap(); updateUI();
        }

        function deleteSelectedArea() {
            if (AppState.selectedAreaIds.length === 0) return;
            if(!confirm("¿Borrar áreas seleccionadas?")) return;
            AppState.selectedAreaIds.forEach(id => {
                AppState.seats = AppState.seats.filter(s => s.areaId !== id);
                AppState.areas = AppState.areas.filter(a => a.id !== id);
            });
            AppState.selectedAreaIds = [];
            renderMap(); updateUI();
        }

        function alignSelection(alignment) {
            if (AppState.selectedAreaIds.length < 2) return;
            const areas = AppState.selectedAreaIds.map(id => AppState.areas.find(a => a.id === id));
            const bounds = areas.map(a => getBounds(a.points));
            let target;
            if (alignment === 'top') {
                target = Math.min(...bounds.map(b => b.minY));
                areas.forEach((a, i) => { const dy = target - bounds[i].minY; a.points = a.points.map(p => ({x: p.x, y: p.y+dy})); });
            } else if (alignment === 'bottom') {
                target = Math.max(...bounds.map(b => b.maxY));
                areas.forEach((a, i) => { const dy = target - bounds[i].maxY; a.points = a.points.map(p => ({x: p.x, y: p.y+dy})); });
            } else if (alignment === 'left') {
                target = Math.min(...bounds.map(b => b.minX));
                areas.forEach((a, i) => { const dx = target - bounds[i].minX; a.points = a.points.map(p => ({x: p.x+dx, y: p.y})); });
            } else if (alignment === 'right') {
                target = Math.max(...bounds.map(b => b.maxX));
                areas.forEach((a, i) => { const dx = target - bounds[i].maxX; a.points = a.points.map(p => ({x: p.x+dx, y: p.y})); });
            }
            renderMap();
        }

        // --- Grid Editor ---
        let isDrawingSeats = false, drawingMode = true;
        function openSeatEditor() {
            if (AppState.selectedAreaIds.length !== 1) return;
            const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]);
            if (!a) return;
            document.getElementById('modal-title').innerText = `${a.title} (${a.code})`;
            document.getElementById('modal-row-min').value = a.rowMin; document.getElementById('modal-row-max').value = a.rowMax;
            document.getElementById('modal-seat-min').value = a.seatMin; document.getElementById('modal-seat-max').value = a.seatMax;
            document.getElementById('seat-modal').classList.remove('hidden');
            renderSeatGrid(a);
        }
        function closeSeatEditor() { document.getElementById('seat-modal').classList.add('hidden'); }
        function updateGridDimensions() {
             const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]); if(!a) return;
             a.rowMin=parseInt(document.getElementById('modal-row-min').value)||a.rowMin; a.rowMax=parseInt(document.getElementById('modal-row-max').value)||a.rowMax;
             a.seatMin=parseInt(document.getElementById('modal-seat-min').value)||a.seatMin; a.seatMax=parseInt(document.getElementById('modal-seat-max').value)||a.seatMax;
             renderSeatGrid(a);
        }
        function expandGrid(d) {
            const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]); if(!a) return;
            if(d==='top') a.rowMax++; if(d==='bottom') a.rowMin--; if(d==='left') a.seatMin--; if(d==='right') a.seatMax++;
            document.getElementById('modal-row-min').value=a.rowMin; document.getElementById('modal-row-max').value=a.rowMax;
            document.getElementById('modal-seat-min').value=a.seatMin; document.getElementById('modal-seat-max').value=a.seatMax;
            renderSeatGrid(a);
        }
        function renderSeatGrid(area) {
            const cont = document.getElementById('grid-container'); cont.innerHTML = '';
            const cols = (area.seatMax - area.seatMin) + 1;
            cont.style.gridTemplateColumns = `30px repeat(${cols}, 24px)`;
            const existing = AppState.seats.filter(s => s.areaId === area.id);
            cont.appendChild(document.createElement('div')); // empty corner
            for (let s=area.seatMin; s<=area.seatMax; s++) { const d=document.createElement('div'); d.className='grid-header-col'; d.innerText=s; cont.appendChild(d); }
            for (let r=area.rowMax; r>=area.rowMin; r--) {
                const dr=document.createElement('div'); dr.className='grid-header-row'; dr.innerText=r; cont.appendChild(dr);
                for (let s=area.seatMin; s<=area.seatMax; s++) {
                    const active = existing.find(x => x.rowPos === r && x.seatPos === s);
                    const c = document.createElement('div'); c.className = `seat-cell ${active?'active':''}`;
                    c.title = `R:${r}, S:${s}`;
                    c.onmousedown=()=>{isDrawingSeats=true; drawingMode=!active; toggleSeat(area,r,s,drawingMode); c.classList.toggle('active',drawingMode);};
                    c.onmouseenter=()=>{if(isDrawingSeats && c.classList.contains('active')!==drawingMode){toggleSeat(area,r,s,drawingMode); c.classList.toggle('active',drawingMode);}};
                    cont.appendChild(c);
                }
            }
            document.getElementById('seat-count-display').innerText = `${existing.length} Asientos`;
        }
        document.addEventListener('mouseup', () => isDrawingSeats=false);
        function toggleSeat(area, r, s, add) {
            const idx = AppState.seats.findIndex(x => x.areaId===area.id && x.rowPos===r && x.seatPos===s);
            if (add && idx===-1) AppState.seats.push({
                seatId: generateUUID(), areaId: area.id, sectorId: area.sectorId,
                rowPos: r, seatPos: s, rowNum: r.toString(), seatNum: s.toString()
            });
            else if (!add && idx!==-1) AppState.seats.splice(idx, 1);
            document.getElementById('seat-count-display').innerText = `${AppState.seats.filter(x=>x.areaId===area.id).length} Asientos`;
        }
        function fillAllSeats() {
            const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]); if(!a) return;
            for(let r=a.rowMin; r<=a.rowMax; r++) for(let s=a.seatMin; s<=a.seatMax; s++) toggleSeat(a,r,s,true);
            renderSeatGrid(a);
        }
        function clearAllSeats() {
            const a = AppState.areas.find(x => x.id === AppState.selectedAreaIds[0]); if(!a) return;
            if(confirm("¿Vaciar?")) {
                for(let r=a.rowMin; r<=a.rowMax; r++) for(let s=a.seatMin; s<=a.seatMax; s++) toggleSeat(a,r,s,false);
                renderSeatGrid(a);
            }
        }

        // Init
        updateUI();
    </script>
</body>
</html>